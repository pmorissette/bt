
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bt.algos &#8212; bt 0.2.9 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/klink.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
         
        <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">
        
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono:400,500,700' rel='stylesheet' type='text/css'>
    
  </head><body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for bt.algos</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of Algos used to create Strategy logic.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">sklearn.covariance</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="kn">import</span> <span class="n">iteritems</span>

<span class="kn">import</span> <span class="nn">bt</span>
<span class="kn">from</span> <span class="nn">bt.core</span> <span class="kn">import</span> <span class="n">Algo</span><span class="p">,</span> <span class="n">AlgoStack</span><span class="p">,</span> <span class="n">SecurityBase</span><span class="p">,</span> <span class="n">is_zero</span>


<div class="viewcode-block" id="run_always"><a class="viewcode-back" href="../../bt.html#bt.algos.run_always">[docs]</a><span class="k">def</span> <span class="nf">run_always</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run always decorator to be used with Algo</span>
<span class="sd">    to ensure stack runs the decorated Algo</span>
<span class="sd">    on each pass, regardless of failures in the stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">run_always</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="PrintDate"><a class="viewcode-back" href="../../bt.html#bt.algos.PrintDate">[docs]</a><span class="k">class</span> <span class="nc">PrintDate</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Algo simply print&#39;s the current date.</span>

<span class="sd">    Can be useful for debugging purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PrintTempData"><a class="viewcode-back" href="../../bt.html#bt.algos.PrintTempData">[docs]</a><span class="k">class</span> <span class="nc">PrintTempData</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Algo prints the temp data.</span>

<span class="sd">    Useful for debugging.</span>

<span class="sd">    Args:</span>
<span class="sd">        * fmt_string (str): A string that will later be formatted with the</span>
<span class="sd">          target&#39;s temp dict. Therefore, you should provide</span>
<span class="sd">          what you want to examine within curly braces ( { } )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PrintTempData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span> <span class="o">=</span> <span class="n">fmt_string</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PrintInfo"><a class="viewcode-back" href="../../bt.html#bt.algos.PrintInfo">[docs]</a><span class="k">class</span> <span class="nc">PrintInfo</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints out info associated with the target strategy. Useful for debugging</span>
<span class="sd">    purposes.</span>

<span class="sd">    Args:</span>
<span class="sd">        * fmt_string (str): A string that will later be formatted with the</span>
<span class="sd">          target object&#39;s __dict__ attribute. Therefore, you should provide</span>
<span class="sd">          what you want to examine within curly braces ( { } )</span>

<span class="sd">    Ex:</span>
<span class="sd">        PrintInfo(&#39;Strategy {name} : {now}&#39;)</span>


<span class="sd">    This will print out the name and the date (now) on each call.</span>
<span class="sd">    Basically, you provide a string that will be formatted with target.__dict__</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt_string</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2"> </span><span class="si">{now}</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PrintInfo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span> <span class="o">=</span> <span class="n">fmt_string</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">target</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Debug"><a class="viewcode-back" href="../../bt.html#bt.algos.Debug">[docs]</a><span class="k">class</span> <span class="nc">Debug</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility Algo that calls pdb.set_trace when triggered.</span>

<span class="sd">    In the debug session, &#39;target&#39; is available and can be examined through the</span>
<span class="sd">    StrategyBase interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pdb</span>

        <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RunOnce"><a class="viewcode-back" href="../../bt.html#bt.algos.RunOnce">[docs]</a><span class="k">class</span> <span class="nc">RunOnce</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on first run then returns False.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_call: bool which determines if it runs the first time the algo is called</span>

<span class="sd">    As the name says, the algo only runs once. Useful in situations</span>
<span class="sd">    where we want to run the logic once (buy and hold for example).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunOnce</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_run</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># if it hasn&#39;t run then we will</span>
        <span class="c1"># run it and set flag</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_run</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># return false to stop future execution</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="RunPeriod"><a class="viewcode-back" href="../../bt.html#bt.algos.RunPeriod">[docs]</a><span class="k">class</span> <span class="nc">RunPeriod</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">run_on_first_date</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">run_on_end_of_period</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">run_on_last_date</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_first_date</span> <span class="o">=</span> <span class="n">run_on_first_date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_end_of_period</span> <span class="o">=</span> <span class="n">run_on_end_of_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_last_date</span> <span class="o">=</span> <span class="n">run_on_last_date</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># get last date</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span>

        <span class="c1"># if none nothing to do - return false</span>
        <span class="k">if</span> <span class="n">now</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># not a known date in our universe</span>
        <span class="k">if</span> <span class="n">now</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># get index of the current date</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># index 0 is a date added by the Backtest Constructor</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># first date</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_first_date</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># last date</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_last_date</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># create pandas.Timestamp for useful .week,.quarter properties</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>

            <span class="n">index_offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_on_end_of_period</span><span class="p">:</span>
                <span class="n">index_offset</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">date_to_compare</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">index_offset</span><span class="p">]</span>
            <span class="n">date_to_compare</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">date_to_compare</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_dates</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="RunPeriod.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunPeriod.compare_dates">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">raise</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;RunPeriod Algo is an abstract class!&quot;</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RunDaily"><a class="viewcode-back" href="../../bt.html#bt.algos.RunDaily">[docs]</a><span class="k">class</span> <span class="nc">RunDaily</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on day change.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_date (bool): determines if it runs the first time the algo is called</span>
<span class="sd">        * run_on_end_of_period (bool): determines if it should run at the end of the period</span>
<span class="sd">          or the beginning</span>
<span class="sd">        * run_on_last_date (bool): determines if it runs on the last time the algo is called</span>

<span class="sd">    Returns True if the target.now&#39;s day has changed</span>
<span class="sd">    compared to the last(or next if run_on_end_of_period) date, if not returns False.</span>
<span class="sd">    Useful for daily rebalancing strategies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RunDaily.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunDaily.compare_dates">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">now</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="RunWeekly"><a class="viewcode-back" href="../../bt.html#bt.algos.RunWeekly">[docs]</a><span class="k">class</span> <span class="nc">RunWeekly</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on week change.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_date (bool): determines if it runs the first time the algo is called</span>
<span class="sd">        * run_on_end_of_period (bool): determines if it should run at the end of the period</span>
<span class="sd">          or the beginning</span>
<span class="sd">        * run_on_last_date (bool): determines if it runs on the last time the algo is called</span>

<span class="sd">    Returns True if the target.now&#39;s week has changed</span>
<span class="sd">    since relative to the last(or next) date, if not returns False. Useful for</span>
<span class="sd">    weekly rebalancing strategies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RunWeekly.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunWeekly.compare_dates">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">now</span><span class="o">.</span><span class="n">year</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">year</span> <span class="ow">or</span> <span class="n">now</span><span class="o">.</span><span class="n">week</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">week</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="RunMonthly"><a class="viewcode-back" href="../../bt.html#bt.algos.RunMonthly">[docs]</a><span class="k">class</span> <span class="nc">RunMonthly</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on month change.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_date (bool): determines if it runs the first time the algo is called</span>
<span class="sd">        * run_on_end_of_period (bool): determines if it should run at the end of the period</span>
<span class="sd">          or the beginning</span>
<span class="sd">        * run_on_last_date (bool): determines if it runs on the last time the algo is called</span>

<span class="sd">    Returns True if the target.now&#39;s month has changed</span>
<span class="sd">    since relative to the last(or next) date, if not returns False. Useful for</span>
<span class="sd">    monthly rebalancing strategies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RunMonthly.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunMonthly.compare_dates">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">now</span><span class="o">.</span><span class="n">year</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">year</span> <span class="ow">or</span> <span class="n">now</span><span class="o">.</span><span class="n">month</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">month</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="RunQuarterly"><a class="viewcode-back" href="../../bt.html#bt.algos.RunQuarterly">[docs]</a><span class="k">class</span> <span class="nc">RunQuarterly</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on quarter change.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_date (bool): determines if it runs the first time the algo is called</span>
<span class="sd">        * run_on_end_of_period (bool): determines if it should run at the end of the period</span>
<span class="sd">          or the beginning</span>
<span class="sd">        * run_on_last_date (bool): determines if it runs on the last time the algo is called</span>

<span class="sd">    Returns True if the target.now&#39;s quarter has changed</span>
<span class="sd">    since relative to the last(or next) date, if not returns False. Useful for</span>
<span class="sd">    quarterly rebalancing strategies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RunQuarterly.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunQuarterly.compare_dates">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">now</span><span class="o">.</span><span class="n">year</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">year</span> <span class="ow">or</span> <span class="n">now</span><span class="o">.</span><span class="n">quarter</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">quarter</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="RunYearly"><a class="viewcode-back" href="../../bt.html#bt.algos.RunYearly">[docs]</a><span class="k">class</span> <span class="nc">RunYearly</span><span class="p">(</span><span class="n">RunPeriod</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on year change.</span>

<span class="sd">    Args:</span>
<span class="sd">        * run_on_first_date (bool): determines if it runs the first time the algo is called</span>
<span class="sd">        * run_on_end_of_period (bool): determines if it should run at the end of the period</span>
<span class="sd">          or the beginning</span>
<span class="sd">        * run_on_last_date (bool): determines if it runs on the last time the algo is called</span>

<span class="sd">    Returns True if the target.now&#39;s year has changed</span>
<span class="sd">    since relative to the last(or next) date, if not returns False. Useful for</span>
<span class="sd">    yearly rebalancing strategies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RunYearly.compare_dates"><a class="viewcode-back" href="../../bt.html#bt.algos.RunYearly.compare_dates">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">date_to_compare</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">now</span><span class="o">.</span><span class="n">year</span> <span class="o">!=</span> <span class="n">date_to_compare</span><span class="o">.</span><span class="n">year</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="RunOnDate"><a class="viewcode-back" href="../../bt.html#bt.algos.RunOnDate">[docs]</a><span class="k">class</span> <span class="nc">RunOnDate</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True on a specific set of dates.</span>

<span class="sd">    Args:</span>
<span class="sd">        * dates (list): List of dates to run Algo on.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">dates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            * dates (*args): A list of dates. Dates will be parsed</span>
<span class="sd">              by pandas.to_datetime so pass anything that it can</span>
<span class="sd">              parse. Typically, you will pass a string &#39;yyyy-mm-dd&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunOnDate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># parse dates and save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dates</span></div>


<div class="viewcode-block" id="RunAfterDate"><a class="viewcode-back" href="../../bt.html#bt.algos.RunAfterDate">[docs]</a><span class="k">class</span> <span class="nc">RunAfterDate</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True after a date has passed</span>

<span class="sd">    Args:</span>
<span class="sd">        * date: Date after which to start trading</span>

<span class="sd">    Note:</span>
<span class="sd">        This is useful for algos that rely on trailing averages where you</span>
<span class="sd">        don&#39;t want to start trading until some amount of data has been built up</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            * date: Date after which to start trading</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunAfterDate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># parse dates and save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span></div>


<div class="viewcode-block" id="RunAfterDays"><a class="viewcode-back" href="../../bt.html#bt.algos.RunAfterDays">[docs]</a><span class="k">class</span> <span class="nc">RunAfterDays</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True after a specific number of &#39;warmup&#39; trading days have passed</span>

<span class="sd">    Args:</span>
<span class="sd">        * days (int): Number of trading days to wait before starting</span>

<span class="sd">    Note:</span>
<span class="sd">        This is useful for algos that rely on trailing averages where you</span>
<span class="sd">        don&#39;t want to start trading until some amount of data has been built up</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">days</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            * days (int): Number of trading days to wait before starting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunAfterDays</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">days</span> <span class="o">=</span> <span class="n">days</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">days</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">days</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RunIfOutOfBounds"><a class="viewcode-back" href="../../bt.html#bt.algos.RunIfOutOfBounds">[docs]</a><span class="k">class</span> <span class="nc">RunIfOutOfBounds</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This algo returns true if any of the target weights deviate by an amount greater</span>
<span class="sd">    than tolerance. For example, it will be run if the tolerance is set to 0.5 and</span>
<span class="sd">    a security grows from a target weight of 0.2 to greater than 0.3.</span>

<span class="sd">    A strategy where rebalancing is performed quarterly or whenever any</span>
<span class="sd">    security&#39;s weight deviates by more than 20% could be implemented by:</span>

<span class="sd">        Or([runQuarterlyAlgo,runIfOutOfBoundsAlgo(0.2)])</span>

<span class="sd">    Args:</span>
<span class="sd">        * tolerance (float): Allowed deviation of each security weight.</span>

<span class="sd">    Requires:</span>
<span class="sd">        * Weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunIfOutOfBounds</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cname</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span>
                <span class="n">deviation</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">weight</span> <span class="o">-</span> <span class="n">targets</span><span class="p">[</span><span class="n">cname</span><span class="p">])</span> <span class="o">/</span> <span class="n">targets</span><span class="p">[</span><span class="n">cname</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">deviation</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s2">&quot;cash&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="n">cash_deviation</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">capital</span> <span class="o">-</span> <span class="n">targets</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">targets</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;cash&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">cash_deviation</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="RunEveryNPeriods"><a class="viewcode-back" href="../../bt.html#bt.algos.RunEveryNPeriods">[docs]</a><span class="k">class</span> <span class="nc">RunEveryNPeriods</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This algo runs every n periods.</span>

<span class="sd">    Args:</span>
<span class="sd">        * n (int): Run each n periods</span>
<span class="sd">        * offset (int): Applies to the first run. If 0, this algo will run the</span>
<span class="sd">          first time it is called.</span>

<span class="sd">    This Algo can be useful for the following type of strategy:</span>
<span class="sd">        Each month, select the top 5 performers. Hold them for 3 months.</span>

<span class="sd">    You could then create 3 strategies with different offsets and create a</span>
<span class="sd">    master strategy that would allocate equal amounts of capital to each.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RunEveryNPeriods</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lcall</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># ignore multiple calls on same period</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcall</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lcall</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span>
            <span class="c1"># run when idx == (n-1)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="SelectAll"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectAll">[docs]</a><span class="k">class</span> <span class="nc">SelectAll</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] with all securities (based on universe).</span>

<span class="sd">    Selects all the securities and saves them in temp[&#39;selected&#39;].</span>
<span class="sd">    By default, SelectAll does not include securities that have no</span>
<span class="sd">    data (nan) on current date or those whose price is zero or negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>
<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectAll</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">universe</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="p">[</span><span class="n">universe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectThese"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectThese">[docs]</a><span class="k">class</span> <span class="nc">SelectThese</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] with a set list of tickers.</span>

<span class="sd">    Args:</span>
<span class="sd">        * ticker (list): List of tickers to select.</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tickers</span><span class="p">,</span> <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectThese</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tickers</span> <span class="o">=</span> <span class="n">tickers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tickers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">universe</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tickers</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="p">[</span><span class="n">universe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectHasData"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectHasData">[docs]</a><span class="k">class</span> <span class="nc">SelectHasData</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on all items in universe that meet</span>
<span class="sd">    data requirements.</span>

<span class="sd">    This is a more advanced version of SelectAll. Useful for selecting</span>
<span class="sd">    tickers that need a certain amount of data for future algos to run</span>
<span class="sd">    properly.</span>

<span class="sd">    For example, if we need the items with 3 months of data or more,</span>
<span class="sd">    we could use this Algo with a lookback period of 3 months.</span>

<span class="sd">    When providing a lookback period, it is also wise to provide a min_count.</span>
<span class="sd">    This is basically the number of data points needed within the lookback</span>
<span class="sd">    period for a series to be considered valid. For example, in our 3 month</span>
<span class="sd">    lookback above, we might want to specify the min_count as being</span>
<span class="sd">    57 -&gt; a typical trading month has give or take 20 trading days. If we</span>
<span class="sd">    factor in some holidays, we can use 57 or 58. It&#39;s really up to you.</span>

<span class="sd">    If you don&#39;t specify min_count, min_count will default to ffn&#39;s</span>
<span class="sd">    get_num_days_required.</span>

<span class="sd">    Args:</span>
<span class="sd">        * lookback (DateOffset): A DateOffset that determines the lookback</span>
<span class="sd">          period.</span>
<span class="sd">        * min_count (int): Minimum number of days required for a series to be</span>
<span class="sd">          considered valid. If not provided, ffn&#39;s get_num_days_required is</span>
<span class="sd">          used to estimate the number of points required.</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>
<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">min_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectHasData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="k">if</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_count</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">get_num_days_required</span><span class="p">(</span><span class="n">lookback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">min_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;selected&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">columns</span>

        <span class="n">filt</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="o">~</span><span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cnt</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectN"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectN">[docs]</a><span class="k">class</span> <span class="nc">SelectN</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on ranking temp[&#39;stat&#39;].</span>

<span class="sd">    Selects the top or botton N items based on temp[&#39;stat&#39;].</span>
<span class="sd">    This is usually some kind of metric that will be computed in a</span>
<span class="sd">    previous Algo and will be used for ranking purposes. Can select</span>
<span class="sd">    top or bottom N based on sort_descending parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        * n (int): select top n items.</span>
<span class="sd">        * sort_descending (bool): Should the stat be sorted in descending order</span>
<span class="sd">          before selecting the first n items?</span>
<span class="sd">        * all_or_none (bool): If true, only populates temp[&#39;selected&#39;] if we</span>
<span class="sd">          have n items. If we have less than n, then temp[&#39;selected&#39;] = [].</span>
<span class="sd">        * filter_selected (bool): If True, will only select from the existing</span>
<span class="sd">          &#39;selected&#39; list.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    Requires:</span>
<span class="sd">        * stat</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sort_descending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_or_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filter_selected</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n cannot be negative&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ascending</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">sort_descending</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_or_none</span> <span class="o">=</span> <span class="n">all_or_none</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_selected</span> <span class="o">=</span> <span class="n">filter_selected</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;stat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_selected</span> <span class="ow">and</span> <span class="s2">&quot;selected&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stat</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">])]</span>
        <span class="n">stat</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ascending</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># handle percent n</span>
        <span class="n">keep_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keep_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">stat</span><span class="p">))</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stat</span><span class="p">[:</span><span class="n">keep_n</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_or_none</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">keep_n</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectMomentum"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectMomentum">[docs]</a><span class="k">class</span> <span class="nc">SelectMomentum</span><span class="p">(</span><span class="n">AlgoStack</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on a simple momentum filter.</span>

<span class="sd">    Selects the top n securities based on the total return over</span>
<span class="sd">    a given lookback period. This is just a wrapper around an</span>
<span class="sd">    AlgoStack with two algos: StatTotalReturn and SelectN.</span>

<span class="sd">    Note, that SelectAll() or similar should be called before</span>
<span class="sd">    SelectMomentum(), as StatTotalReturn uses values of temp[&#39;selected&#39;]</span>

<span class="sd">    Args:</span>
<span class="sd">        * n (int): select first N elements</span>
<span class="sd">        * lookback (DateOffset): lookback period for total return</span>
<span class="sd">          calculation</span>
<span class="sd">        * lag (DateOffset): Lag interval for total return calculation</span>
<span class="sd">        * sort_descending (bool): Sort descending (highest return is best)</span>
<span class="sd">        * all_or_none (bool): If true, only populates temp[&#39;selected&#39;] if we</span>
<span class="sd">          have n items. If we have less than n, then temp[&#39;selected&#39;] = [].</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">sort_descending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">all_or_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectMomentum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">StatTotalReturn</span><span class="p">(</span><span class="n">lookback</span><span class="o">=</span><span class="n">lookback</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">),</span>
            <span class="n">SelectN</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">sort_descending</span><span class="o">=</span><span class="n">sort_descending</span><span class="p">,</span> <span class="n">all_or_none</span><span class="o">=</span><span class="n">all_or_none</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SelectWhere"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectWhere">[docs]</a><span class="k">class</span> <span class="nc">SelectWhere</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects securities based on an indicator DataFrame.</span>

<span class="sd">    Selects securities where the value is True on the current date</span>
<span class="sd">    (target.now) only if current date is present in signal DataFrame.</span>

<span class="sd">    For example, this could be the result of a pandas boolean comparison such</span>
<span class="sd">    as data &gt; 100.</span>

<span class="sd">    Args:</span>
<span class="sd">        * signal (str|DataFrame): Boolean DataFrame containing selection logic.</span>
<span class="sd">          If a string is passed, frame is accessed using target.get_data</span>
<span class="sd">          This is the preferred way of using the algo.</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectWhere</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal_name</span> <span class="o">=</span> <span class="n">signal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># get signal Series at target.now</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="ow">in</span> <span class="n">signal</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span>
            <span class="c1"># get tickers where True</span>
            <span class="c1"># selected = sig.index[sig]</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>  <span class="c1"># noqa: E712</span>
            <span class="c1"># save as list</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
                <span class="n">universe</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">selected</span><span class="p">)]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                    <span class="n">selected</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">selected</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="p">[</span><span class="n">universe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectRandomly"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectRandomly">[docs]</a><span class="k">class</span> <span class="nc">SelectRandomly</span><span class="p">(</span><span class="n">AlgoStack</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on a random subset of</span>
<span class="sd">    the items currently in temp[&#39;selected&#39;].</span>

<span class="sd">    Selects n random elements from the list stored in temp[&#39;selected&#39;].</span>
<span class="sd">    This is useful for benchmarking against a strategy where we believe</span>
<span class="sd">    the selection algorithm is adding value.</span>

<span class="sd">    For example, if we are testing a momentum strategy and we want to see if</span>
<span class="sd">    selecting securities based on momentum is better than just selecting</span>
<span class="sd">    securities randomly, we could use this Algo to create a random Strategy</span>
<span class="sd">    used for random benchmarking.</span>

<span class="sd">    Note:</span>
<span class="sd">        Another selection algorithm should be use prior to this Algo to</span>
<span class="sd">        populate temp[&#39;selected&#39;]. This will typically be SelectAll.</span>

<span class="sd">    Args:</span>
<span class="sd">        * n (int): Select N elements randomly.</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectRandomly</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;selected&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
            <span class="n">universe</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">sel</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="p">[</span><span class="n">universe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectRegex"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectRegex">[docs]</a><span class="k">class</span> <span class="nc">SelectRegex</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on a regex on their names.</span>
<span class="sd">    Useful when working with a large universe of different kinds of securities</span>

<span class="sd">    Args:</span>
<span class="sd">        * regex (str): regular expression on the name</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectRegex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selected</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ResolveOnTheRun"><a class="viewcode-back" href="../../bt.html#bt.algos.ResolveOnTheRun">[docs]</a><span class="k">class</span> <span class="nc">ResolveOnTheRun</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Looks at securities set in temp[&#39;selected&#39;] and searches for names that</span>
<span class="sd">    match the names of &quot;aliases&quot; for on-the-run securities in the provided</span>
<span class="sd">    data. Then replaces the alias with the name of the underlying security</span>
<span class="sd">    appropriate for the given date, and sets it back on temp[&#39;selected&#39;]</span>

<span class="sd">    Args:</span>
<span class="sd">        * on_the_run (str): Name of a Data frame with</span>
<span class="sd">            - columns set to &quot;on the run&quot; ticker names</span>
<span class="sd">            - index set to the timeline for the backtest</span>
<span class="sd">            - values are the actual security name to use for the given date</span>
<span class="sd">        * include_no_data (bool): Include securities that do not have data?</span>
<span class="sd">        * include_negative (bool): Include securities that have negative</span>
<span class="sd">          or zero prices?</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_the_run</span><span class="p">,</span> <span class="n">include_no_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResolveOnTheRun</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_the_run</span> <span class="o">=</span> <span class="n">on_the_run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span> <span class="o">=</span> <span class="n">include_no_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span> <span class="o">=</span> <span class="n">include_negative</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># Resolve real tickers based on OTR</span>
        <span class="n">on_the_run</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_the_run</span><span class="p">)</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">aliases</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">on_the_run</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">resolved</span> <span class="o">=</span> <span class="n">on_the_run</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">aliases</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_no_data</span><span class="p">:</span>
            <span class="n">universe</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">resolved</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_negative</span><span class="p">:</span>
                <span class="n">resolved</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resolved</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">universe</span><span class="p">[</span><span class="n">universe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resolved</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">on_the_run</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SetStat"><a class="viewcode-back" href="../../bt.html#bt.algos.SetStat">[docs]</a><span class="k">class</span> <span class="nc">SetStat</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;stat&#39;] for use by downstream algos (such as SelectN).</span>

<span class="sd">    Args:</span>
<span class="sd">        * stat (str|DataFrame): A dataframe of the same dimension as target.universe</span>
<span class="sd">          If a string is passed, frame is accessed using target.get_data</span>
<span class="sd">          This is the preferred way of using the algo.</span>
<span class="sd">    Sets:</span>
<span class="sd">        * stat</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stat</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_name</span> <span class="o">=</span> <span class="n">stat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat_name</span><span class="p">)</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;stat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="StatTotalReturn"><a class="viewcode-back" href="../../bt.html#bt.algos.StatTotalReturn">[docs]</a><span class="k">class</span> <span class="nc">StatTotalReturn</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;stat&#39;] with total returns over a given period.</span>

<span class="sd">    Sets the &#39;stat&#39; based on the total return of each element in</span>
<span class="sd">    temp[&#39;selected&#39;] over a given lookback period. The total return</span>
<span class="sd">    is determined by ffn&#39;s calc_total_return.</span>

<span class="sd">    Args:</span>
<span class="sd">        * lookback (DateOffset): lookback period.</span>
<span class="sd">        * lag (DateOffset): Lag interval. Total return is calculated in</span>
<span class="sd">          the inteval [now - lookback - lag, now - lag]</span>

<span class="sd">    Sets:</span>
<span class="sd">        * stat</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StatTotalReturn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;stat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prc</span><span class="o">.</span><span class="n">calc_total_return</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighEqually"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighEqually">[docs]</a><span class="k">class</span> <span class="nc">WeighEqually</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] by calculating equal weights for all items in</span>
<span class="sd">    selected.</span>

<span class="sd">    Equal weight Algo. Sets the &#39;weights&#39; to 1/n for each item in &#39;selected&#39;.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighEqually</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">}</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighSpecified"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighSpecified">[docs]</a><span class="k">class</span> <span class="nc">WeighSpecified</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on a provided dict of ticker:weights.</span>

<span class="sd">    Sets the weights based on pre-specified targets.</span>

<span class="sd">    Args:</span>
<span class="sd">        * weights (dict): target weights -&gt; ticker: weight</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">weights</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighSpecified</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># added copy to make sure these are not overwritten</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ScaleWeights"><a class="viewcode-back" href="../../bt.html#bt.algos.ScaleWeights">[docs]</a><span class="k">class</span> <span class="nc">ScaleWeights</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on a scaled version of itself.</span>
<span class="sd">    Useful for going short, or scaling up/down when using</span>
<span class="sd">    :class:`FixedIncomeStrategy &lt;bt.core.FixedIncomeStrategy&gt;`.</span>

<span class="sd">    Args:</span>
<span class="sd">        * scale (float): the scaling factor</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScaleWeights</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighTarget"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighTarget">[docs]</a><span class="k">class</span> <span class="nc">WeighTarget</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets target weights based on a target weight DataFrame.</span>

<span class="sd">    If the target weight dataFrame is  of same dimension</span>
<span class="sd">    as the target.universe, the portfolio will effectively be rebalanced on</span>
<span class="sd">    each period. For example, if we have daily data and the target DataFrame</span>
<span class="sd">    is of the same shape, we will have daily rebalancing.</span>

<span class="sd">    However, if we provide a target weight dataframe that has only month end</span>
<span class="sd">    dates, then rebalancing only occurs monthly.</span>

<span class="sd">    Basically, if a weight is provided on a given date, the target weights are</span>
<span class="sd">    set and the algo moves on (presumably to a Rebalance algo). If not, not</span>
<span class="sd">    target weights are set.</span>

<span class="sd">    Args:</span>
<span class="sd">        * weights (str|DataFrame): DataFrame containing the target weights</span>
<span class="sd">          If a string is passed, frame is accessed using target.get_data</span>
<span class="sd">          This is the preferred way of using the algo.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighTarget</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights_name</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># get current target weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span>

            <span class="c1"># dropna and save</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="WeighInvVol"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighInvVol">[docs]</a><span class="k">class</span> <span class="nc">WeighInvVol</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on the inverse volatility Algo.</span>

<span class="sd">    Sets the target weights based on ffn&#39;s calc_inv_vol_weights. This</span>
<span class="sd">    is a commonly used technique for risk parity portfolios. The least</span>
<span class="sd">    volatile elements receive the highest weight under this scheme. Weights</span>
<span class="sd">    are proportional to the inverse of their volatility.</span>

<span class="sd">    Args:</span>
<span class="sd">        * lookback (DateOffset): lookback period for estimating volatility</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighInvVol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mf">1.0</span><span class="p">}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">tw</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">calc_inv_vol_weights</span><span class="p">(</span><span class="n">prc</span><span class="o">.</span><span class="n">to_returns</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighERC"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighERC">[docs]</a><span class="k">class</span> <span class="nc">WeighERC</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on equal risk contribution algorithm.</span>

<span class="sd">    Sets the target weights based on ffn&#39;s calc_erc_weights. This</span>
<span class="sd">    is an extension of the inverse volatility risk parity portfolio in</span>
<span class="sd">    which the correlation of asset returns is incorporated into the</span>
<span class="sd">    calculation of risk contribution of each asset.</span>

<span class="sd">    The resulting portfolio is similar to a minimum variance portfolio</span>
<span class="sd">    subject to a diversification constraint on the weights of its components</span>
<span class="sd">    and its volatility is located between those of the minimum variance and</span>
<span class="sd">    equally-weighted portfolios (Maillard 2008).</span>

<span class="sd">    See:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Risk_parity</span>

<span class="sd">    Args:</span>
<span class="sd">        * lookback (DateOffset): lookback period for estimating covariance</span>
<span class="sd">        * initial_weights (list): Starting asset weights [default inverse vol].</span>
<span class="sd">        * risk_weights (list): Risk target weights [default equal weight].</span>
<span class="sd">        * covar_method (str): method used to estimate the covariance. See ffn&#39;s</span>
<span class="sd">          calc_erc_weights for more details. (default ledoit-wolf).</span>
<span class="sd">        * risk_parity_method (str): Risk parity estimation method. see ffn&#39;s</span>
<span class="sd">          calc_erc_weights for more details. (default ccd).</span>
<span class="sd">        * maximum_iterations (int): Maximum iterations in iterative solutions</span>
<span class="sd">          (default 100).</span>
<span class="sd">        * tolerance (float): Tolerance level in iterative solutions (default 1E-8).</span>


<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">initial_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">risk_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">covar_method</span><span class="o">=</span><span class="s2">&quot;ledoit-wolf&quot;</span><span class="p">,</span>
        <span class="n">risk_parity_method</span><span class="o">=</span><span class="s2">&quot;ccd&quot;</span><span class="p">,</span>
        <span class="n">maximum_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">WeighERC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_weights</span> <span class="o">=</span> <span class="n">initial_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risk_weights</span> <span class="o">=</span> <span class="n">risk_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">=</span> <span class="n">covar_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risk_parity_method</span> <span class="o">=</span> <span class="n">risk_parity_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_iterations</span> <span class="o">=</span> <span class="n">maximum_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mf">1.0</span><span class="p">}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">tw</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">calc_erc_weights</span><span class="p">(</span>
            <span class="n">prc</span><span class="o">.</span><span class="n">to_returns</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(),</span>
            <span class="n">initial_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_weights</span><span class="p">,</span>
            <span class="n">risk_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">risk_weights</span><span class="p">,</span>
            <span class="n">covar_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span><span class="p">,</span>
            <span class="n">risk_parity_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">risk_parity_method</span><span class="p">,</span>
            <span class="n">maximum_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_iterations</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighMeanVar"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighMeanVar">[docs]</a><span class="k">class</span> <span class="nc">WeighMeanVar</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on mean-variance optimization.</span>

<span class="sd">    Sets the target weights based on ffn&#39;s calc_mean_var_weights. This is a</span>
<span class="sd">    Python implementation of Markowitz&#39;s mean-variance optimization.</span>

<span class="sd">    See:</span>
<span class="sd">        http://en.wikipedia.org/wiki/Modern_portfolio_theory#The_efficient_frontier_with_no_risk-free_asset</span>

<span class="sd">    Args:</span>
<span class="sd">        * lookback (DateOffset): lookback period for estimating volatility</span>
<span class="sd">        * bounds ((min, max)): tuple specifying the min and max weights for</span>
<span class="sd">          each asset in the optimization.</span>
<span class="sd">        * covar_method (str): method used to estimate the covariance. See ffn&#39;s</span>
<span class="sd">          calc_mean_var_weights for more details.</span>
<span class="sd">        * rf (float): risk-free rate used in optimization.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">covar_method</span><span class="o">=</span><span class="s2">&quot;ledoit-wolf&quot;</span><span class="p">,</span>
        <span class="n">rf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighMeanVar</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">=</span> <span class="n">covar_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf</span> <span class="o">=</span> <span class="n">rf</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mf">1.0</span><span class="p">}</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">tw</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">calc_mean_var_weights</span><span class="p">(</span>
            <span class="n">prc</span><span class="o">.</span><span class="n">to_returns</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(),</span>
            <span class="n">weight_bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">covar_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span><span class="p">,</span>
            <span class="n">rf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rf</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="WeighRandomly"><a class="viewcode-back" href="../../bt.html#bt.algos.WeighRandomly">[docs]</a><span class="k">class</span> <span class="nc">WeighRandomly</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;weights&#39;] based on a random weight vector.</span>

<span class="sd">    Sets random target weights for each security in &#39;selected&#39;.</span>
<span class="sd">    This is useful for benchmarking against a strategy where we believe</span>
<span class="sd">    the weighing algorithm is adding value.</span>

<span class="sd">    For example, if we are testing a low-vol strategy and we want to see if</span>
<span class="sd">    our weighing strategy is better than just weighing</span>
<span class="sd">    securities randomly, we could use this Algo to create a random Strategy</span>
<span class="sd">    used for random benchmarking.</span>

<span class="sd">    This is an Algo wrapper around ffn&#39;s random_weights function.</span>

<span class="sd">    Args:</span>
<span class="sd">        * bounds ((low, high)): Tuple including low and high bounds for each</span>
<span class="sd">          security</span>
<span class="sd">        * weight_sum (float): What should the weights sum up to?</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">weight_sum</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WeighRandomly</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_sum</span> <span class="o">=</span> <span class="n">weight_sum</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">random_weights</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_sum</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">rw</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="LimitDeltas"><a class="viewcode-back" href="../../bt.html#bt.algos.LimitDeltas">[docs]</a><span class="k">class</span> <span class="nc">LimitDeltas</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies temp[&#39;weights&#39;] based on weight delta limits.</span>

<span class="sd">    Basically, this can be used if we want to restrict how much a security&#39;s</span>
<span class="sd">    target weight can change from day to day. Useful when we want to be more</span>
<span class="sd">    conservative about how much we could actually trade on a given day without</span>
<span class="sd">    affecting the market.</span>

<span class="sd">    For example, if we have a strategy that is currently long 100% one</span>
<span class="sd">    security, and the weighing Algo sets the new weight to 0%, but we</span>
<span class="sd">    use this Algo with a limit of 0.1, the new target weight will</span>
<span class="sd">    be 90% instead of 0%.</span>

<span class="sd">    Args:</span>
<span class="sd">        * limit (float, dict): Weight delta limit. If float, this will be a</span>
<span class="sd">          global limit for all securities. If dict, you may specify by-ticker</span>
<span class="sd">          limit.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LimitDeltas</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="c1"># determine if global or specific</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_limit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_limit</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">tw</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
        <span class="n">all_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">tw</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
            <span class="n">tgt</span> <span class="o">=</span> <span class="n">tw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tw</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">tgt</span> <span class="o">-</span> <span class="n">cur</span>

            <span class="c1"># check if we need to limit</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_limit</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
                    <span class="n">tw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make sure we have a limit defined in case of limit dict</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
                    <span class="n">lmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lmt</span><span class="p">:</span>
                        <span class="n">tw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="p">(</span><span class="n">lmt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="LimitWeights"><a class="viewcode-back" href="../../bt.html#bt.algos.LimitWeights">[docs]</a><span class="k">class</span> <span class="nc">LimitWeights</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies temp[&#39;weights&#39;] based on weight limits.</span>

<span class="sd">    This is an Algo wrapper around ffn&#39;s limit_weights. The purpose of this</span>
<span class="sd">    Algo is to limit the weight of any one specifc asset. For example, some</span>
<span class="sd">    Algos will set some rather extreme weights that may not be acceptable.</span>
<span class="sd">    Therefore, we can use this Algo to limit the extreme weights. The excess</span>
<span class="sd">    weight is then redistributed to the other assets, proportionally to</span>
<span class="sd">    their current weights.</span>

<span class="sd">    See ffn&#39;s limit_weights for more information.</span>

<span class="sd">    Args:</span>
<span class="sd">        * limit (float): Weight limit.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LimitWeights</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">tw</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># if the limit &lt; equal weight then set weights to 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">tw</span><span class="p">):</span>
            <span class="n">tw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tw</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">limit_weights</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tw</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="TargetVol"><a class="viewcode-back" href="../../bt.html#bt.algos.TargetVol">[docs]</a><span class="k">class</span> <span class="nc">TargetVol</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates temp[&#39;weights&#39;] based on the target annualized volatility desired.</span>

<span class="sd">    Args:</span>
<span class="sd">        * target_volatility: annualized volatility to target</span>
<span class="sd">        * lookback (DateOffset): lookback period for estimating volatility</span>
<span class="sd">        * lag (DateOffset): amount of time to wait to calculate the covariance</span>
<span class="sd">        * covar_method: method of calculating volatility</span>
<span class="sd">        * annualization_factor: number of periods to annualize by.</span>
<span class="sd">          It is assumed that target volatility is already annualized by this factor.</span>

<span class="sd">    Updates:</span>
<span class="sd">        * weights</span>

<span class="sd">    Requires:</span>
<span class="sd">        * temp[&#39;weights&#39;]</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_volatility</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">covar_method</span><span class="o">=</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span>
        <span class="n">annualization_factor</span><span class="o">=</span><span class="mi">252</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">TargetVol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_volatility</span> <span class="o">=</span> <span class="n">target_volatility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">=</span> <span class="n">covar_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annualization_factor</span> <span class="o">=</span> <span class="n">annualization_factor</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>

        <span class="n">current_weights</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">current_weights</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># if there were no weights already set then skip</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">selected</span><span class="p">]</span>
        <span class="n">returns</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">to_returns</span><span class="p">(</span><span class="n">prc</span><span class="p">)</span>

        <span class="c1"># calc covariance matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">==</span> <span class="s2">&quot;ledoit-wolf&quot;</span><span class="p">:</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">ledoit_wolf</span><span class="p">(</span><span class="n">returns</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="n">returns</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;covar_method not implemented&quot;</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="p">[</span><span class="n">current_weights</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">covar</span><span class="o">.</span><span class="n">columns</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">covar</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>

        <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">annualization_factor</span>
        <span class="p">)</span>

        <span class="c1"># vol is too high</span>
        <span class="k">if</span> <span class="n">vol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_volatility</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_volatility</span> <span class="o">/</span> <span class="n">vol</span>
        <span class="c1"># vol is too low</span>
        <span class="k">elif</span> <span class="n">vol</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_volatility</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_volatility</span> <span class="o">/</span> <span class="n">vol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">mult</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PTE_Rebalance"><a class="viewcode-back" href="../../bt.html#bt.algos.PTE_Rebalance">[docs]</a><span class="k">class</span> <span class="nc">PTE_Rebalance</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Triggers a rebalance when PTE from static weights is past a level.</span>

<span class="sd">    Args:</span>
<span class="sd">        * PTE_volatility_cap: annualized volatility to target</span>
<span class="sd">        * target_weights: dataframe of weights that needs to have the same index as the price dataframe</span>
<span class="sd">        * lookback (DateOffset): lookback period for estimating volatility</span>
<span class="sd">        * lag (DateOffset): amount of time to wait to calculate the covariance</span>
<span class="sd">        * covar_method: method of calculating volatility</span>
<span class="sd">        * annualization_factor: number of periods to annualize by.</span>
<span class="sd">          It is assumed that target volatility is already annualized by this factor.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">PTE_volatility_cap</span><span class="p">,</span>
        <span class="n">target_weights</span><span class="p">,</span>
        <span class="n">lookback</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">lag</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">covar_method</span><span class="o">=</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span>
        <span class="n">annualization_factor</span><span class="o">=</span><span class="mi">252</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PTE_Rebalance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PTE_volatility_cap</span> <span class="o">=</span> <span class="n">PTE_volatility_cap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_weights</span> <span class="o">=</span> <span class="n">target_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">=</span> <span class="n">covar_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annualization_factor</span> <span class="o">=</span> <span class="n">annualization_factor</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">prices</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">current_weights</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">*</span> <span class="n">prices</span> <span class="o">/</span> <span class="n">target</span><span class="o">.</span><span class="n">value</span>

        <span class="n">target_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_weights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">current_weights</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">target_weights</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">current_weights</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">target_weights</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="n">target_weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span>
        <span class="n">returns</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">ffn</span><span class="o">.</span><span class="n">to_returns</span><span class="p">(</span><span class="n">prc</span><span class="p">)</span>

        <span class="c1"># calc covariance matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">==</span> <span class="s2">&quot;ledoit-wolf&quot;</span><span class="p">:</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">ledoit_wolf</span><span class="p">(</span><span class="n">returns</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_method</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="n">returns</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;covar_method not implemented&quot;</span><span class="p">)</span>

        <span class="n">PTE_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">annualization_factor</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">PTE_vol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># vol is too high</span>
        <span class="k">if</span> <span class="n">PTE_vol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">PTE_volatility_cap</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="CapitalFlow"><a class="viewcode-back" href="../../bt.html#bt.algos.CapitalFlow">[docs]</a><span class="k">class</span> <span class="nc">CapitalFlow</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to model capital flows. Flows can either be inflows or outflows.</span>

<span class="sd">    This Algo can be used to model capital flows. For example, a pension</span>
<span class="sd">    fund might have inflows every month or year due to contributions. This</span>
<span class="sd">    Algo will affect the capital of the target node without affecting returns</span>
<span class="sd">    for the node.</span>

<span class="sd">    Since this is modeled as an adjustment, the capital will remain in the</span>
<span class="sd">    strategy until a re-allocation/rebalancement is made.</span>

<span class="sd">    Args:</span>
<span class="sd">        * amount (float): Amount of adjustment</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CapitalFlow constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            * amount (float): Amount to adjust by</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CapitalFlow</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amount</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">target</span><span class="o">.</span><span class="n">adjust</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="CloseDead"><a class="viewcode-back" href="../../bt.html#bt.algos.CloseDead">[docs]</a><span class="k">class</span> <span class="nc">CloseDead</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Closes all positions for which prices are equal to zero (we assume</span>
<span class="sd">    that these stocks are dead) and removes them from temp[&#39;weights&#39;] if</span>
<span class="sd">    they enter it by any chance.</span>
<span class="sd">    To be called before Rebalance().</span>

<span class="sd">    In a normal workflow it is not needed, as those securities will not</span>
<span class="sd">    be selected by SelectAll(include_no_data=False) or similar method, and</span>
<span class="sd">    Rebalance() closes positions that are not in temp[&#39;weights&#39;] anyway.</span>
<span class="sd">    However in case when for some reasons include_no_data=False could not</span>
<span class="sd">    be used or some modified weighting method is used, CloseDead() will</span>
<span class="sd">    allow to avoid errors.</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CloseDead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">universe</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">targets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SetNotional"><a class="viewcode-back" href="../../bt.html#bt.algos.SetNotional">[docs]</a><span class="k">class</span> <span class="nc">SetNotional</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the notional_value to use as the base for rebalancing for</span>
<span class="sd">    :class:`FixedIncomeStrategy &lt;bt.core.FixedIncomeStrategy&gt;` targets</span>

<span class="sd">    Args:</span>
<span class="sd">        * notional_value (str): Name of a pd.Series object containing the</span>
<span class="sd">          target notional values of the strategy over time.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * notional_value</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">notional_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notional_value</span> <span class="o">=</span> <span class="n">notional_value</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SetNotional</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">notional_value</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notional_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span> <span class="ow">in</span> <span class="n">notional_value</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;notional_value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">notional_value</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">]</span>

            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Rebalance"><a class="viewcode-back" href="../../bt.html#bt.algos.Rebalance">[docs]</a><span class="k">class</span> <span class="nc">Rebalance</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rebalances capital based on temp[&#39;weights&#39;]</span>

<span class="sd">    Rebalances capital based on temp[&#39;weights&#39;]. Also closes</span>
<span class="sd">    positions if open but not in target_weights. This is typically</span>
<span class="sd">    the last Algo called once the target weights have been set.</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>
<span class="sd">        * cash (optional): You can set a &#39;cash&#39; value on temp. This should be a</span>
<span class="sd">          number between 0-1 and determines the amount of cash to set aside.</span>
<span class="sd">          For example, if cash=0.3, the strategy will allocate 70% of its</span>
<span class="sd">          value to the provided weights, and the remaining 30% will be kept</span>
<span class="sd">          in cash. If this value is not provided (default), the full value</span>
<span class="sd">          of the strategy is allocated to securities.</span>
<span class="sd">        * notional_value (optional): Required only for fixed_income targets. This is the base</span>
<span class="sd">          balue of total notional that will apply to the weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Rebalance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>

        <span class="c1"># save value because it will change after each call to allocate</span>
        <span class="c1"># use it as base in rebalance calls</span>
        <span class="c1"># call it before de-allocation so that notional_value is correct</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">fixed_income</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;notional_value&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;notional_value&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">notional_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># de-allocate children that are not in targets and have non-zero value</span>
        <span class="c1"># (open positions)</span>
        <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="c1"># if this child is in our targets, we don&#39;t want to close it out</span>
            <span class="k">if</span> <span class="n">cname</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># get child and value</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">fixed_income</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">notional_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span>
            <span class="c1"># if non-zero and non-null, we need to close it out</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">target</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">cname</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># If cash is set (it should be a value between 0-1 representing the</span>
        <span class="c1"># proportion of cash to keep), calculate the new &#39;base&#39;</span>
        <span class="k">if</span> <span class="s2">&quot;cash&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">target</span><span class="o">.</span><span class="n">fixed_income</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;cash&quot;</span><span class="p">])</span>

        <span class="c1"># Turn off updating while we rebalance each child</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
            <span class="n">target</span><span class="o">.</span><span class="n">rebalance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">child</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Now update</span>
        <span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RebalanceOverTime"><a class="viewcode-back" href="../../bt.html#bt.algos.RebalanceOverTime">[docs]</a><span class="k">class</span> <span class="nc">RebalanceOverTime</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similar to Rebalance but rebalances to target</span>
<span class="sd">    weight over n periods.</span>

<span class="sd">    Rebalances towards a target weight over a n periods. Splits up the weight</span>
<span class="sd">    delta over n periods.</span>

<span class="sd">    This can be useful if we want to make more conservative rebalacing</span>
<span class="sd">    assumptions. Some strategies can produce large swings in allocations. It</span>
<span class="sd">    might not be reasonable to assume that this rebalancing can occur at the</span>
<span class="sd">    end of one specific period. Therefore, this algo can be used to simulate</span>
<span class="sd">    rebalancing over n periods.</span>

<span class="sd">    This has typically been used in monthly strategies where we want to spread</span>
<span class="sd">    out the rebalancing over 5 or 10 days.</span>

<span class="sd">    Note:</span>
<span class="sd">        This Algo will require the run_always wrapper in the above case. For</span>
<span class="sd">        example, the RunMonthly will return True on the first day, and</span>
<span class="sd">        RebalanceOverTime will be &#39;armed&#39;. However, RunMonthly will return</span>
<span class="sd">        False the rest days of the month. Therefore, we must specify that we</span>
<span class="sd">        want to always run this algo.</span>

<span class="sd">    Args:</span>
<span class="sd">        * n (int): number of periods over which rebalancing takes place.</span>

<span class="sd">    Requires:</span>
<span class="sd">        * weights</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RebalanceOverTime</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rb</span> <span class="o">=</span> <span class="n">Rebalance</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="c1"># new weights specified - update rebalance data</span>
        <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="c1"># if _weights are not None, we have some work to do</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">:</span>
            <span class="n">tgt</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># scale delta relative to # of periods left and set that as the new</span>
            <span class="c1"># target</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span> <span class="k">else</span> <span class="mf">0.0</span>
                <span class="n">dlt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">curr</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span>
                <span class="n">tgt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">+</span> <span class="n">dlt</span>

            <span class="c1"># mock weights and call real Rebalance</span>
            <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rb</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

            <span class="c1"># dec _days_left. If 0, set to None &amp; set _weights to None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_days_left</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Require"><a class="viewcode-back" href="../../bt.html#bt.algos.Require">[docs]</a><span class="k">class</span> <span class="nc">Require</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flow control Algo.</span>

<span class="sd">    This algo returns the value of a predicate</span>
<span class="sd">    on an temp entry. Useful for controlling</span>
<span class="sd">    flow.</span>

<span class="sd">    For example, we might want to make sure we have some items selected.</span>
<span class="sd">    We could pass a lambda function that checks the len of &#39;selected&#39;:</span>

<span class="sd">        pred=lambda x: len(x) == 0</span>
<span class="sd">        item=&#39;selected&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        * pred (Algo): Function that returns a Bool given the strategy. This</span>
<span class="sd">          is the definition of an Algo. However, this is typically used</span>
<span class="sd">          with a simple lambda function.</span>
<span class="sd">        * item (str): An item within temp.</span>
<span class="sd">        * if_none (bool): Result if the item required is not in temp or if it&#39;s</span>
<span class="sd">          value if None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">if_none</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Require</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">if_none</span> <span class="o">=</span> <span class="n">if_none</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_none</span>

        <span class="n">item</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_none</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>


<div class="viewcode-block" id="Not"><a class="viewcode-back" href="../../bt.html#bt.algos.Not">[docs]</a><span class="k">class</span> <span class="nc">Not</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flow control Algo</span>

<span class="sd">    It is usful for &quot;inverting&quot; other flow control algos,</span>
<span class="sd">    For example Not( RunAfterDate(...) ), Not( RunAfterDays(...) ), etc</span>

<span class="sd">    Args:</span>
<span class="sd">        * list_of_algos (Algo): The algo to run and invert the return value of</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algo</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Not</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_algo</span> <span class="o">=</span> <span class="n">algo</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algo</span><span class="p">(</span><span class="n">target</span><span class="p">)</span></div>


<div class="viewcode-block" id="Or"><a class="viewcode-back" href="../../bt.html#bt.algos.Or">[docs]</a><span class="k">class</span> <span class="nc">Or</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flow control Algo</span>

<span class="sd">    It useful for combining multiple signals into one signal.</span>
<span class="sd">    For example, we might want two different rebalance signals to work together:</span>

<span class="sd">        runOnDateAlgo = bt.algos.RunOnDate(pdf.index[0]) # where pdf.index[0] is the first date in our time series</span>
<span class="sd">        runMonthlyAlgo = bt.algos.RunMonthly()</span>
<span class="sd">        orAlgo = Or([runMonthlyAlgo,runOnDateAlgo])</span>

<span class="sd">    orAlgo will return True if it is the first date or if it is 1st of the month</span>

<span class="sd">    Args:</span>
<span class="sd">        * list_of_algos: Iterable list of algos.</span>
<span class="sd">          Runs each algo and</span>
<span class="sd">          returns true if any algo returns true.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_algos</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Or</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list_of_algos</span> <span class="o">=</span> <span class="n">list_of_algos</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">algo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_of_algos</span><span class="p">:</span>
            <span class="n">tempRes</span> <span class="o">=</span> <span class="n">algo</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">|</span> <span class="n">tempRes</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SelectTypes"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectTypes">[docs]</a><span class="k">class</span> <span class="nc">SelectTypes</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on node type.</span>
<span class="sd">    If temp[&#39;selected&#39;] is already set, it will filter the existing</span>
<span class="sd">    selection.</span>

<span class="sd">    Args:</span>
<span class="sd">        * include_types (list): Types of nodes to include</span>
<span class="sd">        * exclude_types (list): Types of nodes to exclude</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_types</span><span class="o">=</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Node</span><span class="p">,),</span> <span class="n">exclude_types</span><span class="o">=</span><span class="p">()):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelectTypes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_types</span> <span class="o">=</span> <span class="n">include_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_types</span> <span class="o">=</span> <span class="n">exclude_types</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sec_name</span>
            <span class="k">for</span> <span class="n">sec_name</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_types</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_types</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;selected&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]]</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selected</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ClosePositionsAfterDates"><a class="viewcode-back" href="../../bt.html#bt.algos.ClosePositionsAfterDates">[docs]</a><span class="k">class</span> <span class="nc">ClosePositionsAfterDates</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Close positions on securities after a given date.</span>
<span class="sd">    This can be used to make sure positions on matured/redeemed securities are</span>
<span class="sd">    closed. It can also be used as part of a strategy to, i.e. make sure</span>
<span class="sd">    the strategy doesn&#39;t hold any securities with time to maturity less than a year</span>

<span class="sd">    Note that if placed after a RunPeriod algo in the stack, that the actual</span>
<span class="sd">    closing of positions will occur after the provided date. For this to work,</span>
<span class="sd">    the &quot;price&quot; of the security (even if matured) must exist up until that date.</span>
<span class="sd">    Alternatively, run this with the @run_always decorator to close the positions</span>
<span class="sd">    immediately.</span>

<span class="sd">    Also note that this algo does not operate using temp[&#39;weights&#39;] and Rebalance.</span>
<span class="sd">    This is so that hedges (which are excluded from that workflow) will also be</span>
<span class="sd">    closed as necessary.</span>

<span class="sd">    Args:</span>
<span class="sd">        * close_dates (str): the name of a dataframe indexed by security name, with columns</span>
<span class="sd">          &quot;date&quot;: the date after which we want to close the position ASAP</span>

<span class="sd">    Sets:</span>
<span class="sd">        * target.perm[&#39;closed&#39;] : to keep track of which securities have already closed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">close_dates</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ClosePositionsAfterDates</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_dates</span> <span class="o">=</span> <span class="n">close_dates</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;closed&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;closed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">close_dates</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">close_dates</span><span class="p">)[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span>
        <span class="c1"># Find securities that are candidate for closing</span>
        <span class="n">sec_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sec_name</span>
            <span class="k">for</span> <span class="n">sec_name</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">SecurityBase</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">close_dates</span><span class="o">.</span><span class="n">index</span>
            <span class="ow">and</span> <span class="n">sec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;closed&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="c1"># Check whether closed</span>
        <span class="n">is_closed</span> <span class="o">=</span> <span class="n">close_dates</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sec_names</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span>

        <span class="c1"># Close position</span>
        <span class="k">for</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">is_closed</span><span class="p">[</span><span class="n">is_closed</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">sec_name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;closed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sec_name</span><span class="p">)</span>

        <span class="c1"># Now update</span>
        <span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RollPositionsAfterDates"><a class="viewcode-back" href="../../bt.html#bt.algos.RollPositionsAfterDates">[docs]</a><span class="k">class</span> <span class="nc">RollPositionsAfterDates</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll securities based on the provided map.</span>
<span class="sd">    This can be used for any securities which have &quot;On-The-Run&quot; and &quot;Off-The-Run&quot;</span>
<span class="sd">    versions (treasury bonds, index swaps, etc).</span>

<span class="sd">    Also note that this algo does not operate using temp[&#39;weights&#39;] and Rebalance.</span>
<span class="sd">    This is so that hedges (which are excluded from that workflow) will also be</span>
<span class="sd">    rolled as necessary.</span>

<span class="sd">    Args:</span>
<span class="sd">        * roll_data (str): the name of a dataframe indexed by security name, with columns</span>
<span class="sd">            - &quot;date&quot;: the first date at which the roll can occur</span>
<span class="sd">            - &quot;target&quot;: the security name we are rolling into</span>
<span class="sd">            - &quot;factor&quot;: the conversion factor. One unit of the original security</span>
<span class="sd">              rolls into &quot;factor&quot; units of the new one.</span>

<span class="sd">    Sets:</span>
<span class="sd">        * target.perm[&#39;rolled&#39;] : to keep track of which securities have already rolled</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roll_data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RollPositionsAfterDates</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roll_data</span> <span class="o">=</span> <span class="n">roll_data</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;rolled&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;rolled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">roll_data</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roll_data</span><span class="p">)</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Find securities that are candidate for roll</span>
        <span class="n">sec_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sec_name</span>
            <span class="k">for</span> <span class="n">sec_name</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">SecurityBase</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">roll_data</span><span class="o">.</span><span class="n">index</span>
            <span class="ow">and</span> <span class="n">sec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;rolled&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="c1"># Calculate new transaction and close old position</span>
        <span class="k">for</span> <span class="n">sec_name</span><span class="p">,</span> <span class="n">sec_fields</span> <span class="ow">in</span> <span class="n">roll_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sec_names</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sec_fields</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="s2">&quot;rolled&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sec_name</span><span class="p">)</span>
                <span class="n">new_quantity</span> <span class="o">=</span> <span class="n">sec_fields</span><span class="p">[</span><span class="s2">&quot;factor&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">target</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
                <span class="n">new_sec</span> <span class="o">=</span> <span class="n">sec_fields</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">new_sec</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">:</span>
                    <span class="n">transactions</span><span class="p">[</span><span class="n">new_sec</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_quantity</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transactions</span><span class="p">[</span><span class="n">new_sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_quantity</span>
                <span class="n">target</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">sec_name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Do all the new transactions at the end, to do any necessary aggregations first</span>
        <span class="k">for</span> <span class="n">new_sec</span><span class="p">,</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">transactions</span><span class="p">):</span>
            <span class="n">target</span><span class="o">.</span><span class="n">transact</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="n">new_sec</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Now update</span>
        <span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SelectActive"><a class="viewcode-back" href="../../bt.html#bt.algos.SelectActive">[docs]</a><span class="k">class</span> <span class="nc">SelectActive</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets temp[&#39;selected&#39;] based on filtering temp[&#39;selected&#39;] to exclude</span>
<span class="sd">    those securities that have been closed or rolled after a certain date</span>
<span class="sd">    using ClosePositionsAfterDates or RollPositionsAfterDates. This makes sure</span>
<span class="sd">    not to select them again for weighting (even if they have prices).</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>
<span class="sd">        * perm[&#39;closed&#39;] or perm[&#39;rolled&#39;]</span>

<span class="sd">    Sets:</span>
<span class="sd">        * selected</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>
        <span class="n">rolled</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rolled&quot;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">perm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;closed&quot;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">rolled</span><span class="p">,</span> <span class="n">closed</span><span class="p">)]</span>
        <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selected</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ReplayTransactions"><a class="viewcode-back" href="../../bt.html#bt.algos.ReplayTransactions">[docs]</a><span class="k">class</span> <span class="nc">ReplayTransactions</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replay a list of transactions that were executed.</span>
<span class="sd">    This is useful for taking a blotter of actual trades that occurred,</span>
<span class="sd">    and measuring performance against hypothetical strategies.</span>
<span class="sd">    In particular, one can replay the outputs of backtest.Result.get_transactions</span>

<span class="sd">    Note that this allows the timestamps and prices of the reported transactions</span>
<span class="sd">    to be completely arbitrary, so while the strategy may track performance</span>
<span class="sd">    on a daily basis, it will accurately account for the actual PNL of</span>
<span class="sd">    the trades based on where they actually traded, and the bidofferpaid</span>
<span class="sd">    attribute on the strategy will capture the &quot;slippage&quot; as measured</span>
<span class="sd">    against the daily prices.</span>

<span class="sd">    Args:</span>
<span class="sd">        * transactions (str): name of a MultiIndex dataframe with format</span>
<span class="sd">          Date, Security | quantity, price.</span>
<span class="sd">          Note this schema follows the output of backtest.Result.get_transactions</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transactions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ReplayTransactions</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transactions</span> <span class="o">=</span> <span class="n">transactions</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">timeline</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">timeline</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="o">.</span><span class="n">min</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">timeline</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Get the transactions since the last update</span>
        <span class="n">all_transactions</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transactions</span><span class="p">)</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">all_transactions</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;Date&quot;</span><span class="p">)</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="n">all_transactions</span><span class="p">[(</span><span class="n">timestamps</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timestamps</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">security</span><span class="p">),</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="n">transactions</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">security</span><span class="p">]</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transact</span><span class="p">(</span>
                <span class="n">transaction</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">],</span> <span class="n">price</span><span class="o">=</span><span class="n">transaction</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="c1"># Now update</span>
        <span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SimulateRFQTransactions"><a class="viewcode-back" href="../../bt.html#bt.algos.SimulateRFQTransactions">[docs]</a><span class="k">class</span> <span class="nc">SimulateRFQTransactions</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An algo that simulates the outcomes from RFQs (Request for Quote)</span>
<span class="sd">    using a &quot;model&quot; that determines which ones becomes transactions and at what price</span>
<span class="sd">    those transactions happen. This can be used from the perspective of the sender of the</span>
<span class="sd">    RFQ or the receiver.</span>

<span class="sd">    Args:</span>
<span class="sd">        * rfqs (str): name of a dataframe with columns</span>
<span class="sd">          Date, Security | quantity, *additional columns as required by model</span>
<span class="sd">        * model (object): a function/callable object with arguments</span>
<span class="sd">                - rfqs : data frame of rfqs to respond to</span>
<span class="sd">                - target : the strategy object, for access to position and value data</span>
<span class="sd">          and which returns a set of transactions, a MultiIndex DataFrame with:</span>
<span class="sd">                Date, Security | quantity, price</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rfqs</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimulateRFQTransactions</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfqs</span> <span class="o">=</span> <span class="n">rfqs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">timeline</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">timeline</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">now</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="o">.</span><span class="n">min</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">timeline</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Get the RFQs since the last update</span>
        <span class="n">all_rfqs</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rfqs</span><span class="p">)</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">all_rfqs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;Date&quot;</span><span class="p">)</span>
        <span class="n">rfqs</span> <span class="o">=</span> <span class="n">all_rfqs</span><span class="p">[(</span><span class="n">timestamps</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timestamps</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)]</span>

        <span class="c1"># Turn the RFQs into transactions</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">rfqs</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">security</span><span class="p">),</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="n">transactions</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">security</span><span class="p">]</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transact</span><span class="p">(</span>
                <span class="n">transaction</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">],</span> <span class="n">price</span><span class="o">=</span><span class="n">transaction</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="c1"># Now update</span>
        <span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<span class="k">def</span> <span class="nf">_get_unit_risk</span><span class="p">(</span><span class="n">security</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">unit_risks</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">security</span><span class="p">]</span>
        <span class="n">unit_risk</span> <span class="o">=</span> <span class="n">unit_risks</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># No risk data, assume zero</span>
        <span class="n">unit_risk</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">unit_risk</span>


<div class="viewcode-block" id="UpdateRisk"><a class="viewcode-back" href="../../bt.html#bt.algos.UpdateRisk">[docs]</a><span class="k">class</span> <span class="nc">UpdateRisk</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tracks a risk measure on all nodes of the strategy. To use this node, the</span>
<span class="sd">    ``additional_data`` argument on :class:`Backtest &lt;bt.backtest.Backtest&gt;` must</span>
<span class="sd">    have a &quot;unit_risk&quot; key. The value should be a dictionary, keyed</span>
<span class="sd">    by risk measure, of DataFrames with a column per security that is sensitive to that measure.</span>

<span class="sd">    Args:</span>
<span class="sd">        * name (str): the name of the risk measure (IR01, PVBP, IsIndustials, etc).</span>
<span class="sd">          The name must coincide with the keys of the dictionary passed to additional_data as the</span>
<span class="sd">          &quot;unit_risk&quot; argument.</span>
<span class="sd">        * history (int): The level of depth in the tree at which to track the time series of risk numbers.</span>
<span class="sd">          i.e. 0=no tracking, 1=first level only, etc. More levels is more expensive.</span>

<span class="sd">    Modifies:</span>
<span class="sd">        * The &quot;risk&quot; attribute on the target and all its children</span>
<span class="sd">        * If history==True, the &quot;risks&quot; attribute on the target and all its children</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UpdateRisk</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;UpdateRisk&gt;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">measure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>

    <span class="k">def</span> <span class="nf">_setup_risk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">set_history</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Setup risk attributes on the node in question &quot;&quot;&quot;</span>
        <span class="n">target</span><span class="o">.</span><span class="n">risk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">set_history</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">risks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">set_history</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Setup a risk measure within the risk attributes on the node in question &quot;&quot;&quot;</span>
        <span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="k">if</span> <span class="n">set_history</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">risks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

    <span class="k">def</span> <span class="nf">_set_risk_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">unit_risk_frame</span><span class="p">):</span>
        <span class="n">set_history</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>
        <span class="c1"># General setup of risk on nodes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;risk&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_risk</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">set_history</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_measure</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">set_history</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">bt</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">SecurityBase</span><span class="p">):</span>
            <span class="c1"># Use target.root.now as non-traded securities may not have been updated yet</span>
            <span class="c1"># and there is no need to update them here as we only use position</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">unit_risk_frame</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
            <span class="n">unit_risk</span> <span class="o">=</span> <span class="n">_get_unit_risk</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">unit_risk_frame</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_zero</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="p">):</span>
                <span class="n">risk</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">risk</span> <span class="o">=</span> <span class="n">unit_risk</span> <span class="o">*</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span> <span class="o">*</span> <span class="n">target</span><span class="o">.</span><span class="n">multiplier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">risk</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_risk_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">unit_risk_frame</span><span class="p">)</span>
                <span class="n">risk</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">risk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span>

        <span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="n">risk</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">risks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="n">risk</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">unit_risk_frame</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s2">&quot;unit_risk&quot;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_risk_recursive</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unit_risk_frame</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PrintRisk"><a class="viewcode-back" href="../../bt.html#bt.algos.PrintRisk">[docs]</a><span class="k">class</span> <span class="nc">PrintRisk</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Algo prints the risk data.</span>

<span class="sd">    Args:</span>
<span class="sd">        * fmt_string (str): A string that will later be formatted with the</span>
<span class="sd">          target object&#39;s risk attributes. Therefore, you should provide</span>
<span class="sd">          what you want to examine within curly braces ( { } )</span>
<span class="sd">          If not provided, will print the entire dictionary with no formatting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt_string</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PrintRisk</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span> <span class="o">=</span> <span class="n">fmt_string</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;risk&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="HedgeRisks"><a class="viewcode-back" href="../../bt.html#bt.algos.HedgeRisks">[docs]</a><span class="k">class</span> <span class="nc">HedgeRisks</span><span class="p">(</span><span class="n">Algo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hedges risk measures with selected instruments.</span>

<span class="sd">    Make sure that the UpdateRisk algo has been called beforehand.</span>

<span class="sd">    Args:</span>
<span class="sd">        * measures (list): the names of the risk measures to hedge</span>
<span class="sd">        * pseudo (bool): whether to use the pseudo-inverse to compute</span>
<span class="sd">          the inverse Jacobian. If False, will fail if the number</span>
<span class="sd">          of selected instruments is not equal to the number of</span>
<span class="sd">          measures, or if the Jacobian is singular</span>
<span class="sd">        * strategy (StrategyBase): If provided, will hedge the risk</span>
<span class="sd">          from this strategy in addition to the risk from target.</span>
<span class="sd">          This is to allow separate tracking of hedged and unhedged</span>
<span class="sd">          performance. Note that risk_strategy must occur earlier than</span>
<span class="sd">          &#39;target&#39; in a depth-first traversal of the children of the root,</span>
<span class="sd">          otherwise hedging will occur before positions of risk_strategy are</span>
<span class="sd">          updated.</span>
<span class="sd">        * throw_nan (bool): Whether to throw on nan hedge notionals, rather</span>
<span class="sd">          than simply not hedging.</span>

<span class="sd">    Requires:</span>
<span class="sd">        * selected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measures</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">throw_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HedgeRisks</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must pass in at least one measure to hedge&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measures</span> <span class="o">=</span> <span class="n">measures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="n">pseudo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throw_nan</span> <span class="o">=</span> <span class="n">throw_nan</span>

    <span class="k">def</span> <span class="nf">_get_target_risk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">measure</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;risk&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;risk not set up on target </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">measure</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;measure </span><span class="si">%s</span><span class="s2"> not set on target </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">measure</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">risk</span><span class="p">[</span><span class="n">measure</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">securities</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">temp</span><span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">]</span>

        <span class="c1"># Get target risk</span>
        <span class="n">target_risk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_target_risk</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measures</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add the target risk of the strategy to the risk of the target</span>
            <span class="c1"># (which contains existing hedges)</span>
            <span class="n">target_risk</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_target_risk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measures</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="c1"># Turn target_risk into a column array</span>
        <span class="n">target_risk</span> <span class="o">=</span> <span class="n">target_risk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measures</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get hedge risk as a Jacobian matrix</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measures</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s2">&quot;unit_risk&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;unit_risk for </span><span class="si">%s</span><span class="s2"> not present in temp on </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

        <span class="n">hedge_risk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">_get_unit_risk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">securities</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get hedge ratios</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">hedge_risk</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">hedge_risk</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">notionals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="o">-</span><span class="n">target_risk</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Hedge</span>
        <span class="k">for</span> <span class="n">notional</span><span class="p">,</span> <span class="n">security</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">notionals</span><span class="p">,</span> <span class="n">securities</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">notional</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">throw_nan</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has nan hedge notional&quot;</span> <span class="o">%</span> <span class="n">security</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">transact</span><span class="p">(</span><span class="n">notional</span><span class="p">,</span> <span class="n">security</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
        <aside>

            
            <a href="../../index.html" id="logo" title=bt><img class="logo" src="../../_static/logo.png" width="150px" height="150px" title=bt /></a>
            
            
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html"> Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html"> Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algos.html"> All About Algos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tree.html"> The Tree Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"> Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bt.html"> API</a></li>
</ul>


            
            <ul>
                <li><a href="https://github.com/pmorissette/bt">Github</a></li>
            </ul>
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </aside>
    
      <div class="clearer"></div>
    </div>
        <div class="footer">
            bt was created by Philippe Morissette. If you find a bug, please <a href="https://github.com/pmorissette/bt/issues/new" title="Open a new issue on Github">submit an issue</a> on Github.
        </div>

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-52308448-3', 'auto');
            ga('require', 'displayfeatures');
            ga('send', 'pageview');
        </script>
        
  </body>
</html>